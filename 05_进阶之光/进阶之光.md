# 一、自定义View

## 0、重要函数列表

View的函数：

| 函数名                                  | 作用                         |
| --------------------------------------- | ---------------------------- |
| int  getWidth（） /  int  getHeight（） | 获取宽/高                    |
| layout（L,T,R,B）                       | 重新放置View                 |
| invalidate()                            | 让View调用ondraw导致重新绘制 |



ViewGroup的函数

| 函数名                                 | 作用                             |
| -------------------------------------- | -------------------------------- |
| dispatchTouchEvent（MotionEvent e）    | 事件分发                         |
| onInterceptTouchEvent（MotionEvent e） | 事件的拦截，在上个方法中调用     |
| onTouchEvent（MotionEvent e）          | 处理点击事件，在第一个方法中调用 |











## 1、View基础

### 1、坐标系

<img src="C:\Users\31367\AppData\Roaming\Typora\typora-user-images\image-20220511232117608.png" alt="image-20220511232117608" style="zoom:67%;" />

触摸点位通过 event 事件来获取 View 的坐标



### 2、View的滑动

①` layout（L,T,R,B）`

​	计算出需要滑动的距离，再通过`layout() `重新放置	

② `offsetLeftAndRight(OffsetX)`  和  ` offsetTopAndButtom(OffsetY)`

​    根据`offsetX`和`Y`的值移动`View`

③`LayoutParams` 和 `ViewGroup.MarginLayoutParams`

```java
//使用LayoutParams，由于父布局是LinearLayout，所以采用LinearLayout.LayoutParams
LinearLayout.LayoutParams layoutParams= (LinearLayout.LayoutParams) getLayoutParams();
layoutParams.leftMargin = getLeft() + offsetX;
layoutParams.topMargin = getTop() + offsetY;
setLayoutParams(layoutParams);
```

```java
//使用MarginLayoutParams，后续一致
ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams) getLayoutParams();
```

④属性动画

```java
ObjectAnimator.ofFloat(view, "translationX", 200, 500)
    .setDuration(500)
    .start();
```



⑤ `scrollTo(offsetX,offsetY)` 和 `scrllBy(offsetX,offsetY)`

​	1.移动`View`的内容，如果是在`ViewGroup`中，则移动的是所有子`View`。

​	2.它的参考系为画布，所以和正常移动的值相反（左正，右负，上正，下负）。

​	3.瞬间完成

```
 ((View)getParent()).scrollBy(-offsetX,-offsetY);
```

想要达到逐步绘制的效果，就需要借助Scroller完成。案例：eg1.1







### 3、详解属性动画

使用属性动画，要操作的属性必须有get和set方法，否则无法生效。但可以自定义一个包装类，增加get和set方法。

```java
public  class MyView {
    private View targetView;

    public MyView(View targetView) {
        this.targetView = targetView;
    }

    //自定义的get/set
    public int  getWidth(){
        return targetView.getLayoutParams().width;
    }

    public void setWidth(int width){
        targetView.getLayoutParams().width=width;
        targetView.requestLayout();
    }
}
```

```java
CustomView customView = findViewById(R.id.customview);
MyView myView=new MyView(customView);

//width属性
ObjectAnimator.ofInt(myView, "width", 200, 500)
    .setDuration(500)
    .start();
```





动画插值器：可以知道当前动画改变的数值，从而更新UI

```java
ValueAnimator valueAnimator=ValueAnimator.ofFloat(0,100);
valueAnimator.setTarget(textView);
valueAnimator.setDuration(2000).start();
valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        float value= (float) animation.getAnimatedValue();
        textView.setText((int)value+"");
    }
});
```



动画有四个过程：Start、Repeat、End、Cancel，可以选择事件进行监听

```java
ObjectAnimator animator=ObjectAnimator.ofFloat(btn,"alpha",1.5f);
animator.addListener(new AnimatorListenerAdapter() {
    @Override
    public void onAnimationEnd(Animator animation) {
        super.onAnimationEnd(animation);
    }
});
```





动画的组合：

```java
AnimatorSet set = new AnimatorSet(); //设置一个动画集合一起播放
set.playTogether(animator, animator2);
//set.play(animator).with(animator2).after(animator3);
set.setDuration(500);
set.start();
```





### 案例：

#### eg1.1



Scroller 和 scrollTo 完成逐帧的动画效果

```java
public class CustomView extends View {
    private int lastX;
    private int lastY;
    private Scroller mScroller;

    public CustomView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);

    }

    public CustomView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mScroller = new Scroller(context);
    }

    public CustomView(Context context) {
        super(context);
    }


    public boolean onTouchEvent(MotionEvent event) {
        //获取到手指处的横坐标和纵坐标
        int x = (int) event.getX();
        int y = (int) event.getY();
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                lastX = x;
                lastY = y;
                break;
            case MotionEvent.ACTION_MOVE:
                //计算移动的距离
                int offsetX = x - lastX;
                int offsetY = y - lastY;
                //使用scrollBy 完成移动
                ((View)getParent()).scrollBy(-offsetX,-offsetY);
                break;
        }
        return true;
    }

    ///重写computeScroll，并使用Scroller对象完成逐帧的绘制
    @Override
    public void computeScroll() {
        super.computeScroll();
        if(mScroller.computeScrollOffset()){
            ((View) getParent()).scrollTo(mScroller.getCurrX(),mScroller.getCurrY());
            //通过不断的重绘不断的调用computeScroll方法
            invalidate();
        }

    }
}
```



invalidate  ->  ondraw   ->  computeScroll  ->  scrollTo







## 2、事件分发



![image-20211205214727738](C:\Users\31367\Desktop\note\02_进阶之路\自定义View.assets\image-20211205214727738.png)







## 3、自定义属性讲解

类似在XML布局文件中引用的，app命名空间的，都是自定义的属性：

```xml
  xmlns:app="http://schemas.android.com/apk/res-auto"
```



比如此时我自定义了一个控件，引入了app命名空间的my_age，my_bg ，my_name等属性

```xml
 <com.atguigu.autoattribute.MyAttributeView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:my_age="100"
        app:my_bg="@drawable/jtx"
        app:my_name="android0220"/>
```



此时，需要在res/attr中创建一个属性集合，定义申明的自定义属性：

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!--定义名字叫MyAttributeView属性集合-->
    <declare-styleable name="MyAttributeView">
        
        <!--定义一个名字叫my_name并且类型是string的属性-->
        <attr name="my_name" format="string"/>
        
        <!--定义一个名字叫my_age并且类型是integer的属性-->
        <attr name="my_age" format="integer"/>
        
        <!--定义一个名字叫my_bg并且类型是reference|color的属性-->
        <attr name="my_bg" format="reference|color"/>
    </declare-styleable>
</resources>
```



之后，就可以在自定义的View中，获取该属性并绘制相应的内容：

```java
public class MyAttributeView extends View {
    private int myAge;
    private String myName;
    private Bitmap myBg;

    public MyAttributeView(Context context, AttributeSet attrs) {
        super(context, attrs);

        //获取属性三种方式
        //1.用命名空间取获取
        String age = attrs.getAttributeValue("http://schemas.android.com/apk/res-auto","my_age");
        String name = attrs.getAttributeValue("http://schemas.android.com/apk/res-auto","my_name");
        String bg = attrs.getAttributeValue("http://schemas.android.com/apk/res-auto","my_bg");
//        System.out.println("age=="+age+",name=="+name+",bg==="+bg);

        //2.遍历属性集合
        for(int i=0;i<attrs.getAttributeCount();i++){
            System.out.println(attrs.getAttributeName(i)+"====="+attrs.getAttributeValue(i));
        }

        //3.使用系统工具，获取属性
        TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.MyAttributeView);
       for(int i=0;i<typedArray.getIndexCount();i++){
          int index =  typedArray.getIndex(i);

           switch (index){
               case R.styleable.MyAttributeView_my_age:
                   myAge = typedArray.getInt(index,0);
                   break;
               case R.styleable.MyAttributeView_my_name:
                   myName = typedArray.getString(index); //获取自定义属性的值
                   break;
               case R.styleable.MyAttributeView_my_bg:
                   Drawable drawable = typedArray.getDrawable(index);
                   //BitmapDrawable是Drawable子类
                   BitmapDrawable drawable1 = (BitmapDrawable) drawable;
                   myBg = drawable1.getBitmap();
                   break;
           }
       }
        // 记得回收
        typedArray.recycle();
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        Paint paint = new Paint();
        canvas.drawText(myName+"---"+myAge,50,50,paint);
        canvas.drawBitmap(myBg,50,50,paint);
    }
}
```







## 4、自定义View

1、直接继承自View的自定义View，在源码中getRootMeasureSpec方法里，可以看到 WRAP_CONTENT 的 的MeasureSpec 是AT_MOST，所以自定义View的时候，需要在onMeasure 中单独处理 WRAP_CONTENT  属性值。

2、自定义View，如果在没有在onDraw方法里处理 padding ，则XML设置padding不会生效

```java
public class RectView extends View {
    private Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
    private int mColor=Color.RED;
    
    public RectView(Context context) {
        super(context);
        initDraw();
    }

    public RectView(Context context, AttributeSet attrs) {
        super(context, attrs);
        initDraw();
    }

    public RectView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        initDraw();
    }

    private void initDraw() {
        mPaint.setColor(mColor);
        mPaint.setStrokeWidth((float) 1.5);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
        int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
        int widthSpecSize=MeasureSpec.getSize(widthMeasureSpec);
        int heightSpecSize=MeasureSpec.getSize(heightMeasureSpec);
       
        //处理 WRAP_CONTENT 的默认值为600px
       if(widthSpecMode==MeasureSpec.AT_MOST&&heightSpecMode==MeasureSpec.AT_MOST){
            setMeasuredDimension(600,600);
        }else if(widthSpecMode==MeasureSpec.AT_MOST){
            setMeasuredDimension(600,heightSpecSize);
        }else if(heightSpecMode==MeasureSpec.AT_MOST){
            setMeasuredDimension(widthSpecSize,600);
        }
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        int paddingLeft = getPaddingLeft();
        int paddingRight = getPaddingRight();
        int paddingTop = getPaddingTop();
        int paddingBottom = getPaddingBottom();
        int width = getWidth() - paddingLeft - paddingRight;
        int height = getHeight() - paddingTop - paddingBottom;
        //计算padding
        canvas.drawRect(0 + paddingLeft, 0 + paddingTop, width + paddingLeft, height + paddingTop, mPaint);
    }
}
```





















