# 一、Constraintlayout

用视图界面作比例基本能满足大部分的要求，但还需要对控件属性有一些基本的认知



```xml
  <TextView
        android:id="@+id/main_tv_print_get_res"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="hello world"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
```

app:layout_constraintLeft_toLeftOf="parent"

当这个属性只存在一个的时候，代表控件的左边和谁对其

当 app:layout_constraintRight_toRightOf="parent" 出现时，代表控件处于二者连线居中的位置











## 特殊属性



### 1.控件所占百分比：

在控件的宽高为0dp时，起到最佳效果作用

```xml
 <TextView
        android:id="@+id/main_tv_print_get_res"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:gravity="center"
        android:text="控件占领整个屏幕的50%"		
        android:textSize="20sp"
        app:layout_constraintHeight_percent="0.5"	//高度50%
        app:layout_constraintWidth_percent="0.5"	//宽度50%
        app:layout_constraintLeft_toLeftOf="parent"	
        app:layout_constraintTop_toTopOf="parent"/>
```

效果：紧贴左上角，控件大小为整个屏幕的1/4



### 2.控件的百分比定位：

如水平方向的百分比定位，一定要在==控件左右约束都确定==的情况下才发挥作用

```xml
 <TextView
        android:id="@+id/main_tv_print_get_res"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:gravity="center"
        android:text="控件占领整个屏幕的50%"
        android:textSize="20sp"
        app:layout_constraintHorizontal_bias="0.3"		//关键代码，水平方向的定位
        app:layout_constraintVertical_bias="0.4"		//关键代码，垂直方向的定位
        app:layout_constraintHeight_percent="0.5"
        app:layout_constraintWidth_percent="0.5"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"	//补充右侧的约束
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"	//补充底部的约束/>
```

<img src="%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20210821225621394.png" alt="image-20210821225621394" style="zoom:33%;" />

控件的中心位置位于水平方向的30%，垂直方向的中心位于整体布局的40%处



### 3.权重

分为水平和竖直方向，均有约束时起作用

```xml
<Button
    android:id="@+id/btn1"
    android:layout_width="0dp"
    android:layout_height="wrap_content"
    android:text="hello world"
    app:layout_constraintHorizontal_weight="1"	//关键代码
    app:layout_constraintLeft_toLeftOf="parent"
    app:layout_constraintRight_toRightOf="parent"
    app:layout_constraintTop_toTopOf="parent" />
```



这样表示在水平方向上两个按钮以2：1分配

```xml
<Button
    android:id="@+id/btn1"
    android:layout_width="0dp"
    android:layout_height="wrap_content"
    android:text="hello world"
    app:layout_constraintHorizontal_weight="2"
    app:layout_constraintEnd_toStartOf="@id/btn2"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintTop_toTopOf="parent"/>

<Button
    android:id="@+id/btn2"
    android:layout_width="0dp"
    android:layout_height="wrap_content"
    android:text="hello world1"
    app:layout_constraintHorizontal_weight="1"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toEndOf="@id/btn1"
    app:layout_constraintTop_toTopOf="parent"/>
```





### 4.宽高比

```xml
	<ImageView
        android:layout_width="0dp"
        android:layout_height="0dp"		//宽高至少一个为0
        android:background="@drawable/mipma"
        app:layout_constraintDimensionRatio="1:2"		//这行代码
        app:layout_constraintLeft_toLeftOf="parent"		
        app:layout_constraintRight_toRightOf="parent"/>
```





### 5.防止控件越界

```xml
 <TextView
        android:id="@+id/tv1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="11111111111111111111111111111111111111"
        app:layout_constrainedWidth="true"	//关键代码
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toLeftOf="@id/tv2"
        app:layout_constraintTop_toTopOf="parent" />

    <TextView
        android:id="@+id/tv2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="11111111111111"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toBottomOf="@id/tv1" />

```

效果图：

![image-20210821234256570](%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20210821234256570.png)





### 6.Chain

chainStyle类型取值：

* spread: 控件均匀分布，即控件之间（包括边框）间距相同
* spread_inside: 第一个和最后一个控件固定在链两端的约束边界上，其余控件均匀分布，即控件内部之间间距相同
* packed: 控件打包在一起（在考虑外边距之后）。 然后，通过更改链的头视图偏差调整整条链的偏差（左/右或上/下）。

![image-20210822125250281](%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20210822125250281.png)





某几个控件之间首尾相接，排列方式有特殊要求

```xml
  <TextView
        android:id="@+id/tv1"
        android:layout_width="wrap_content"
        android:layout_height="80dp"
        android:background="#00897B"
        android:text="1111"
        android:textColor="#fff"
        android:textSize="20sp"
        android:gravity="center"
        app:layout_constraintHorizontal_chainStyle="spread_inside"	//关键代码
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toStartOf="@id/tv2"
        app:layout_constraintStart_toStartOf="parent" />

    <TextView
        android:id="@+id/tv2"
        android:layout_width="wrap_content"
        android:layout_height="50dp"
        android:background="#3700B3"
        android:gravity="center"
        android:text="2222"
        android:textColor="#fff"
        android:textSize="20sp"
        app:layout_constraintBaseline_toBaselineOf="@id/tv1"	//让其基准线对准第一个控件
        app:layout_constraintEnd_toStartOf="@id/tv3"
        app:layout_constraintStart_toEndOf="@id/tv1" />

    <TextView
        android:id="@+id/tv3"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:background="#FB8C00"
        android:text="3333"
        android:textColor="#fff"
        android:textSize="20sp"
        app:layout_constraintBaseline_toBaselineOf="@id/tv1"//让其基准线对准第一个控件
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toEndOf="@id/tv2" />
```





# 二、Glide

优点：用多少加载多少图片资源，不造成内存的浪费或益处问题

## 1 准备工作

引入依赖

```
dependencies {
    compile 'com.github.bumptech.glide:glide:3.7.0'
}
```

网络权限:

```
<uses-permission android:name="android.permission.INTERNET" />
```



## 2 简单使用

从网络上加载一张图片（包括 gif 图片）

```java
 public void loadImage(View view) {
        String url = "http://cn.bing.com/az/hprichbg/rb/Dongdaemun_ZH-CN10736487148_1920x1080.jpg";
        Glide.with(this)		//this决定了图片的生命周期
            .load(url)
            .asBitmap()		//只能加载静态图片，剔出GIF
            .asGif()		//只加载gif图片
            .placeholder(R.drawable.loading)	//资源加载占位图
            .error(R.drawable.error)  //资源下载出错时的占位图
			.diskCacheStrategy(DiskCacheStrategy.NONE)		//禁用缓存
            .override(100,100) //把图片加载成100*100，不管ImageView大小
            .into(imageView);		
    }
```

load()方法的其他用法，还可以加载本地图片、应用资源等等

```java
// 加载本地图片
File file = new File(getExternalCacheDir() + "/image.jpg");
Glide.with(this).load(file).into(imageView);

// 加载应用资源
int resource = R.drawable.image;
Glide.with(this).load(resource).into(imageView);

// 加载二进制流
byte[] image = getImageBytes();
Glide.with(this).load(image).into(imageView);

// 加载Uri对象
Uri imageUri = getImageUri();
Glide.with(this).load(imageUri).into(imageView);
```



# 三、Lomhok

使用注解快速生成get、set、toString等



## 1 准备工作：

下载插件，File——settings——plugins

引入依赖库：

```java
implementation 'javax.annotation:javax.annotation-api:1.2'
implementation 'org.projectlombok:lombok:1.16.6'
annotationProcessor 'org.projectlombok:lombok:1.16.6'    //apt插件引用
```



## 2 简单使用

### 2.1 Getter和Setter

```java
//(AccessLevel.PRIVATE)设置set方法的权限级别
@Setter(AccessLevel.PRIVATE)
@ToString
public class Person {
    String name;
    int age;
    boolean fale;
}
```



### 2.2 ToString

toString 时，如果没有设置值，则会用默认值，int = 0 ； String = null 

```java
//callSuper = true 代表调用父类同名方法
//exclude = {"age"} 代表排除age字段
@ToString(callSuper = true, exclude = {"age"})
public class Person extends Thread {
    String name;
    int age;
    boolean fale;
}

   public void show_person(View view){
        Person p = new Person();
        p.setName("zhangsan");	//父类有这个方法，属性设置给父类
//        p.setAge(18);	//因为父类没有这个方法，会报错
        Toast.makeText(this, p.toString(), Toast.LENGTH_SHORT).show();
    }
//最终效果为：
//Person(super=Thread[zhangsan,5,main], name=null, fale=false)
```





### 2.3 EqualsAndHashCode

重写equals和hashCode ，括号里的字段排除和引用父类方法类同ToString



### 2.4 构造器

```java
@Setter
@NoArgsConstructor	//无参构造
@AllArgsConstructor(suppressConstructorProperties = true)	//满参构造
@ToString
public class Person {
    String name;
    int age;
    boolean fale;
}
```



### 2.5 Data

生成get、set、toString、EqualsAndHashCode 

```java
@Data
public class Person {
    String name;
    int age;
    boolean fale;
}
```



# 四、Retrofit

## 1 引入框架

```java
implementation 'com.squareup.retrofit2:retrofit:2.0.2'
```





## 2 简单使用演示

### 2.1 定义接口

```java
public interface PostRequest {
    @POST("productSeries")      //使用Post请求，通常将请求目录和相对路径分开写入
    @FormUrlEncoded         //使用表单方式提交
    //@Field为提交时的请求参数名，后面跟着的类型为形参变量
    Call<ResponseBody> getBody(@Field("type") String type, @Field("languageId") int id);
}
```



### 2.2 发送请求

```java
    public void show_Response(View view){
        //创建Retrofit对象
        Retrofit retrofit = new Retrofit.Builder()
            	//请求目录，必须以/结尾
                .baseUrl("https://api.xhorse.net.cn/release/project/app-xhorse/supportandad/webContent/")
                .addConverterFactory(GsonConverterFactory.create())
                .build();
        //创建网络接口请求实例
        PostRequest request = retrofit.create(PostRequest.class);
        //通过接口的方法获取到call对象
        Call<ResponseBody> call = request.getBody("0", 1);
        //异步请求
        call.enqueue(new Callback<ResponseBody>() {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    Log.e("MA", response.body().string() );
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            @Override
            public void onFailure(Call<ResponseBody> call, Throwable t) {

            }
        });
    }
```

得到  JSON格式的响应体数据





## 3 请求并解析JSON

### 3.1 引入Gson依赖

此依赖含有Retrofit，所以不需要单独再引入Retrofit

```java
implementation 'com.squareup.retrofit2:converter-gson:2.0.2'		//此依赖为Gson解析，此外还有SpimleXML等
```



### 3.2 定义对象和接口

定义通过请求返回的 对应的实体类对象：

```java
@Data
public class Product<T> {
    private int status;
    private String message;
    private ArrayList<Data> data;

    //注意：内部类必须用static修饰，否则构造对象时,Data对象会持有Product对象，出现问题
    @lombok.Data
    public static class Data {
        private String id;
        private String createAt;
        private String updateAt;
        private String startDate;
        private String overDate;
        private String userCode;
        private String paramJson;
        private String title;
        private String languageId;
        private String content;
        private String imageUrl;
        private String isDisplay;
        private String isDelete;
    }
}
```

> 注意：@Data为Lomhok的使用



定义请求接口：

```java
public interface PostRequest {
    @POST("productSeries")     
    @FormUrlEncoded        
    Call<Product> getProduct(@Field("type") String type, @Field("languageId") int id); 
}
```



### 3.3 构建请求的实例对象

```java
 public void show_bean(View view) {
        //创建Retrofit对象
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl("https://api.xhorse.net.cn/release/project/app-xhorse/supportandad/webContent/")
                .addConverterFactory(GsonConverterFactory.create())
                .build();
        PostRequest request = retrofit.create(PostRequest.class);
        Call<Product> call = request.getProduct("0", 1);
        //异步执行请求对象
        call.enqueue(new Callback<Product>() {
            @Override
            public void onResponse(Call<Product> call, Response<Product> response) {
                Log.e("MA", response.body().toString());
                //获取请求体中的Data数组
                ArrayList<Product.Data> datas = response.body().getData();
                Log.e("MA", datas.get(1).getTitle());
            }

            @Override
            public void onFailure(Call<Product> call, Throwable t) {
                Log.e("MA", "连接失败");
                t.printStackTrace();
            }
        });
    }
}
```







## 4 请求并解析XML

这次依然使用Post请求，但请求参数（XML格式）在整个请求体里，以文本形式存在，不是以form表单发送

### 4.1 引入simplexml依赖

此依赖含有Retrofit，所以不需要单独再引入Retrofit

```
  implementation 'com.squareup.retrofit2:converter-simplexml:2.0.2'
```

 

### 4.2 接口和实体类：

```java
public interface PostRequest {
    @POST("customer-account")     
    Call<RespBody> login(@Body RequestBody body);
}
```

```java
@Data
@NoArgsConstructor    //无参构造
@AllArgsConstructor(suppressConstructorProperties = true)    //满参构造
//当类名和返回的XML名称不相同时，用name指定对应的XML名称；相同则不需要
//strict = false表示XML中有，但实体类中没有的元素
//根节点元素，或在XML中的元素为根节点时，用Root表示
@Root(name = "body", strict = false)	
public class RespBody {
    @Element
    private int code;
    @Element
    private String msg;
    @Element
    private Data data;
    @Element(name = "time-cost")
    private String time_cost;

    //同样，内部类用static表示，也可以用外部类不加static
    @lombok.Data
    @NoArgsConstructor	//无参构造
    @AllArgsConstructor(suppressConstructorProperties = true)	//满参构造
    @Root
    public static class Data {
        @Element
        private String login_token;
        @Element
        private String customer_id;
        @Element
        private String customer_level;
        @Element
        private String customer_nickname;
        @Element
        private String avatar;
        @Element
        private String level;
        @Element
        private String customer_nation_code;
        @Element
        private String customer_tel;
        @Element
        private String login_id;
        @Element
        private String is_foreign;
        @Element(required = false)  //返回体数据为空或不存在该属性时，一定要使用该注解
        private String factory_code;
    }
    				
	//如果存在数组元素，用以下方式表示， inLine=true 表示该元素和根节点相连，即只有一层，不存在多层嵌套
    //@ElmentList(entry="xml中的节点名称"，inLine=true)
    //ArrayList<T> t
    
    
    //如果节点存在属性值，则需要新建一个类表示该节点，类中属性为节点的属性，用注解 @Attribute 标识
    //如果存在多个属性值，则节点用 @ElementList 标识
}
```

### 4.3 发送请求并解析

```java
   public void show_xml(View view) {
        //创建Retrofit对象
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl("https://api.xhorse.net.cn/release/project/")
                .addConverterFactory(SimpleXmlConverterFactory.create())    //xml转换器
                .build();

        //构建所需要的requestBody体
        String xml = "<body><user-agent-info>手机型号:real6580_we_m,系统版本:6.0,APP版本:10309</user-agent-info><password>YHYmy123</password><language-id>1</language-id><user-agent-uuid>a5d8c399bddb3f830dcd9a7ededd14e0</user-agent-uuid><action>1</action><mobile>16671492011</mobile><version>284</version><nation-code>86</nation-code></body>";
        RequestBody requestBody = RequestBody.create(MediaType.parse("text/xml;charset=utf-8"), xml);

        //创建网络接口请求实例，发送请求
        PostRequest request = retrofit.create(PostRequest.class);
        Call<RespBody> call = request.login(requestBody);
        call.enqueue(new Callback<RespBody>() {
            @Override
            public void onResponse(Call<RespBody> call, Response<RespBody> response) {
                Log.e("MA",  response.body().toString() );
                RespBody body = response.body();
                RespBody.Data data = body.getData();
                Log.e("MA", data.getCustomer_tel());
            }

            @Override
            public void onFailure(Call<RespBody> call, Throwable t) {
                Log.e("MA","请求失败"+t.toString());
            }
        });
    }
```



# 五、ButterKnife

## 1.配置相关

* AS中下载Butterknife插件

![image-20210827231420853](%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20210827231420853.png)

* BuildGradle中去申明JAVA版本和依赖相关

```java
android {
    //……
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}

dependencies {
 		//……
    implementation 'com.jakewharton:butterknife:10.2.3'
    annotationProcessor 'com.jakewharton:butterknife-compiler:10.2.3'
}

```





==注意==：控件一定不能是static



## 2.活动中使用

```java
public class MainActivity extends AppCompatActivity {
    @BindView(R.id.helloword)
    TextView mTextView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
      
        ButterKnife.bind(this);		//关键语句，不然找不到控件

        mTextView.setText("你好");
    }

    @OnClick({R.id.btn, R.id.helloword})
    public void onClick(View view) {
        switch (view.getId()) {
            case R.id.btn:
               //处理逻辑
                break;
            case R.id.helloword:
                Toast.makeText(this, "你好", Toast.LENGTH_SHORT).show();
                break;
            default:
                break;
        }
    }
  	//也可以一个方法配一个Onclick注解，就不需要参数和判断了
}
```



## 3.Fragment中使用

```java
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container,
                         Bundle savedInstanceState) {
    View view = inflater.inflate(R.layout.fragment_blank, container, false);
    ButterKnife.bind(this, view);		//this+view，其余相同
    return view;
}
```





## 4.ViewHolder

```java
 static class ViewHolder extends RecyclerView.ViewHolder {
        @BindView(R.id.fruit_image)
        ImageView fruitImage;
        @BindView(R.id.fruit_name)
        TextView fruitName;

        public ViewHolder(View view) {      //构造函数，这个view就是RecyclerView子项的最外层布局
            super(view);
            ButterKnife.bind(this, view);		//这句话足够
        }
    }
```





# 六、EventBus

主要用于各组件之间的通信，需要在活动生命周期进行注册和反注册，作用类似于广播。



订阅函数的执行由参数中的事件类的类名决定。

## 1.引入依赖

```java
implementation 'org.greenrobot:eventbus:3.2.0'
```



## 2.注册和反注册

```java
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //注册
        EventBus.getDefault().register(this);
    }

		@Override
    protected void onDestroy() {
        super.onDestroy();
        //反注册
        EventBus.getDefault().unregister(this);
    }
```



## 3.发送和接收

```java
    //在需要的地方发送
    EventBus.getDefault().post(response.toString());

		//接收
		@Subscribe(threadMode = ThreadMode.MAIN)
    public void onEvent(String msg) {		//可以传任何对象
        msgcontent.setText(msg);
    }
```



注解中又有四种模式：

| 模式                 | 描述                                                         |
| -------------------- | ------------------------------------------------------------ |
| ThreadMode.MAIN      | 无论事件是在哪个线程发布出来的，该事件订阅方法onEvent都会在UI线程中执行 |
| ThreadMode.POSTING   | 发布事件和接收事件在同一个线程。使用这个方法时，在onEvent方法中不能执行耗时操作，如果执行耗时操作容易导致事件分发延迟。 |
| hreadMode.BACKGROUND | UI线程中发布出来的，那么订阅函数onEvent就会在子线程中运行，如果事件本来就是在子线程中发布出来的，那么订阅函数直接在该子线程中执行 |
| hreadMode.AYSNC      | 无论事件在哪个线程发布，都会创建新的子线程来执行订阅函数     |







# 七、沉浸式

一般的设置：

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        //获取到当前界面的decorView
        View decorView = getWindow().getDecorView();
        //全屏显示的属性（隐藏状态栏），下拉显示
//        int option = View.SYSTEM_UI_FLAG_FULLSCREEN;
      
        //状态栏和导航栏隐藏，触摸任意位置显示
//        int option = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN;
      
        //透明状态栏（5.0以上系统支持）
//        int option = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE;

        //透明的状态栏和导航栏，要配合下面的setNavigationBarColor和setStatusBarColor使用
        int option = View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION  //这个属性是让应用占用系统导航栏的空间
                | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                | View.SYSTEM_UI_FLAG_LAYOUT_STABLE;
        
        getWindow().setNavigationBarColor(Color.TRANSPARENT); //设置为透明色
        getWindow().setStatusBarColor(Color.TRANSPARENT);

        //设置UI可见性参数
        decorView.setSystemUiVisibility(option);
        
        //将actionBar也隐藏
        ActionBar actionBar = getSupportActionBar();
        actionBar.hide();
    }
```



完全沉浸式：

直接重写以下方法即可

```
 @Override
    public void onWindowFocusChanged(boolean hasFocus) {
        super.onWindowFocusChanged(hasFocus);
        if (hasFocus && Build.VERSION.SDK_INT >= 19) {
            View decorView = getWindow().getDecorView();
            decorView.setSystemUiVisibility(
                View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                | View.SYSTEM_UI_FLAG_FULLSCREEN
                | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);
        }
    }
```









# 八、Stream流

Android miniSdk<24时加入依赖：

```java
    implementation 'com.annimon:stream:1.2.1'
```



实例：

筛选出年龄为18的人数

```java
        ArrayList<Person> persons = new ArrayList<>();
        persons.add(new Person("张三", 18));
        persons.add(new Person("李四", 17));
        persons.add(new Person("王五", 20));
        persons.add(new Person("赵六", 18));

        ArrayList<Integer> ages = (ArrayList<Integer>) Stream.of(persons).filter(person -> person.getAge() == 18).map(person -> person.getAge()).collect(Collectors.toList());
        if (ages.isEmpty()) {
            Toast.makeText(this, "无数据", Toast.LENGTH_SHORT).show();
        } else {
            Toast.makeText(this, ages.size()+"", Toast.LENGTH_SHORT).show();
        }
```







