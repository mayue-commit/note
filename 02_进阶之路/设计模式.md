# 一、概念

设计模式是面向对象设计原则的实际运行，对类的封装继承多态以及类的关联关系和组合的充分理解。



## 1、分类：

### 1.创建型模式

特点是将对象的创建与使用分离。包括：单例、原型、工厂方法、抽象工厂、建造者



### 2.结构型模式

描述如何将类或对象按某种布局组成更大的结构。包括：代理、适配器、桥接、装饰、外观、享元、组合



### 3.行为型模式

类或对象之间怎样相互协作共同完成单个对象无法完成的任务，以及怎么分配职责。包括：模板方法、策略、命令、责任链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器。





# 二、UML



## 1、类图



### 1.类的表示

<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20211213223944547.png" alt="image-20211213223944547" style="zoom: 67%;" />

- +：表示public
- -：表示private
- #：表示protect

> 属性的初始化值可选，跟在类型的后面。





### 2.类之间的关系

关联关系是一类对象和另一类对象之间的联系。如：老师和学生。分为一般关联关系、聚合关系、组合关系。



#### ①一般关联

分为单项关联、双向关联、自关联



##### 单向关联：

![image-20211213225057650](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20211213225057650.png)

每个顾客都有一个地址，Customer类持有Address类的对象







##### 双向关联：

![image-20211213225227563](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20211213225227563.png)

顾客有多个商品，Product类申明Customer对象表示被谁购买





##### 自关联：

![image-20211213225353194](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20211213225353194.png)

自己包含自己，如LinkedList







#### ②聚合关系

强关联关系，是整体和部分之间的关系。

![image-20211213225518646](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20211213225518646.png)



成员对象可以脱离整体对象独立存在。如大学倒闭了，老师仍然存在。

> 菱形指向整体





#### ③组合关系

是整体和部分之间的关系，但更强烈。

![image-20211213225722873](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20211213225722873.png)



整体对象可以控制部分对象的生命周期，整体对象不存在了，部分对象也不存在。





#### ④依赖关系

是一种使用关系，耦合度最弱的关联

![image-20211213230040664](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20211213230040664.png)

某个类的方法通过局部变量、方法的参数、或对静态方法的调用访问另一个类中的某些方法，完成职责。



#### ⑤继承关系（泛化关系）

耦合度最大的一种关系，父类和子类的关系。

![image-20211213230409650](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20211213230409650.png)







#### ⑥实现关系

接口和实现类的关系

![image-20211213230927017](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20211213230927017.png)





# 三、软件设计原则

为了提高软件系统的可维护性和可复用性，提高开发效率，节约软件开发成本和维护成本



## 1、开闭原则

程序需要扩展的时候，不能修改原有代码，实现一个热插拔的效果。（接口和抽象类）





## 2、里氏代换原则

任何基类可以出现的地方，子类一定可以出现。即子类可以扩展父类的功能，但不能改变父类原有的功能。尽量别重写父类的方法。









## 3、依赖倒转原则

高层模块不依赖低层模块，两者都应该依赖其抽象，抽象不应该依赖细节，细节应该依赖抽象。（对抽象编程，不对实现类编程），是开闭原则的具体实现。

![image-20211229221951548](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20211229221951548.png)





## 4、接口隔离原则

一个类对另一个类的依赖应该建立在最小的接口上

![image-20211229223924176](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20211229223924176.png)



## 5、最少知识原则（迪米特法则）

**代理模式**

只和你的直接朋友交谈，不和陌生人说话。【如果两个软件实体无法直接通信，不应当发生直接的相互调用，通过第三方转发调用，降低类的耦合度，调高模块的相对独立性】

“朋友”是指当前对象本身，方法参数，成员对象、所创建的对象等

![image-20211229225353418](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20211229225353418.png)







## 6、合成复用原则

尽量先使用组合或者聚合等关联关系实现，其次考虑使用继承关系实现。



因为继承有以下缺点：

1.破坏了类的封装，父类对子类是透明的，所以这种复用称为”白箱复用“

2.子类与父类耦合度高，父类的任何实现都会导致子类的实现发生变化，不利于类的扩展和维护

3.限制了复用的灵活性，从父类继承而来的实现是静态的，编译时已经定义，运行时不可能发生变化



相对的，组合或聚合，将已有对象纳入新的对象，成为新对象的一部分。优点：

1.维持了类的封装性，因为成分对象的内部细节是新对象看不见的

2.耦合度地，在类的成员位置声明抽象

3.复用的灵活性高，可以在运行时动态进行。即只声名未赋值，需要的时候再赋值。





# 四、设计模式



## 1、创建者模式



### 1.单例模式

#### 饿汉式：

类加载的时候创建单例对象。==枚举单例模式属于饿汉式。==



使用静态成员变量，或者静态代码块的方式加载。缺点：不使用就会造成内存的浪费

```java
class SingleTon {
    //私有构造
    private SingleTon(){}

    //静态单例成员变量
    private static SingleTon instance=new SingleTon();
    
    public static SingleTon getInstance(){
        return instance;
    }
}
```







#### 懒汉式：

首次使用该对象时创建



缺点：线程不安全

```java
class SingleTon {
    //私有构造
    private SingleTon(){}

    //静态单例成员变量
    private static SingleTon instance;

    public static SingleTon getInstance(){
        if(instance==null){
            instance =new SingleTon();
        }
        return instance;
    }
}
```



##### 改进：双重检查锁：

多线程的情况下，可能出现空指针，因为JVM在实例化对象的时候会进行优化和指令重排序。使用`volatile`关键字可以保证可见性和有序性

```java
class SingleTon {
    //私有构造
    private SingleTon() {
    }

    //静态单例成员变量
    private static volatile SingleTon instance;

    public static SingleTon getInstance() {
        if (instance == null) {
            synchronized (SingleTon.class) {
                //双重检查锁
                if (instance == null) {
                    instance = new SingleTon();
                }
            }
        }
        return instance;
    }
}
```







##### 静态内部类的方式：

JVM加载外部类的过程中不会加载静态内部类，方法被调用时才会加载并初始化静态属性。不加锁的情况下保证了线程安全，且没有任何性能影响和空间的浪费

```java
class SingleTon {
    //私有构造
    private SingleTon() {
    }

    //内部类中初始化外部类对象
    private static class SingleTonHolder{
        private static final SingleTon INSTANCE=new SingleTon();
    } 

    public static SingleTon getInstance() {
        return SingleTonHolder.INSTANCE;
    }
}

```





#### 破坏单例模式：

1.使用序列化和反序列化的方式可以破坏，使用ObjectOutputStream/ObjectInputStream读取文件中的对象，打印发现地址值发生了变化



解决办法：ObjectInputSream的源码中，会判断对象有无ReadResolve()方法，有则调用

<img src="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220102153323073.png" alt="image-20220102153323073" style="zoom:50%;" />

所以在单例对象中添加该方法，并实现即可。

```java
    public Object readResovle(){
        return SingleTonHolder.INSTANCE;
    }
```



2.暴力反射

```java
            Class<SingleTon> singleTonClass = SingleTon.class;
            Constructor<SingleTon> cons = null;
            cons = singleTonClass.getDeclaredConstructor();
            cons.setAccessible(true);

            SingleTon singleTon1 = cons.newInstance();
            SingleTon singleTon2 = cons.newInstance();
            System.out.println(singleTon1==singleTon2);
```

解决办法，在构造中判断，如果对象存在，直接抛出异常。为了防止线程不安全问题还可以加入sychornic









### 2.工厂模式

最大的优点：解耦





#### 简单工厂模式

不是设计模式，更像编程习惯。它将各类对象抽象到了工厂类中，但工厂类和具体产品依然存在耦合关系，不合符开闭原则。也可以定义为静态的模式，这样就避免了创建对象的过程。





#### 工厂方法模式

结构：抽象工厂、具体工厂、抽象产品、具体产品

![image-20220102165240964](%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/image-20220102165240964.png)



优点：只需要知道具体的工厂名称就可获得所要的产品，无需知道产品的创建过程

在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无需对原工厂修改。但会增加系统的复杂度。



















## 2、结构型模式



















## 3、行为型模式





### 1.观察者模式

又称发布-订阅模式，一对多的依赖关系，让多个观察者对象监听某一个主题对象，状态发生变化时通知所有的观察者，使他们能够自动更新自己





























